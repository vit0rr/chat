<!-- 
HTML page generated by I.A. It's not that good but works 
-->

<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Chat</title>
    <style>
        #messages {
            height: 300px;
            overflow-y: scroll;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        .message {
            margin: 5px 0;
        }
        .loading {
            text-align: center;
            padding: 10px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="messages"></div>
    <input type="text" id="messageInput" placeholder="Type your message...">
    <button onclick="sendMessage()">Send</button>
    <button id="lockButton" onclick="lockRoom()">Lock Room</button>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room_id') || 'default-room';
        const userId = urlParams.get('user_id') || 'anonymous-user';
        const nickname = urlParams.get('nickname') || 'anonymous-user';

        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        
        let currentPage = 1;
        let isLoading = false;
        let hasMore = true;

        // Load initial messages
        loadMessages();

        // Infinite scroll handler
        messagesDiv.addEventListener('scroll', () => {
            if (messagesDiv.scrollTop === 0 && !isLoading && hasMore) {
                loadMessages();
            }
        });

        async function loadMessages() {
            if (isLoading) return;
            
            isLoading = true;
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading';
            loadingDiv.textContent = 'Loading messages...';
            messagesDiv.insertBefore(loadingDiv, messagesDiv.firstChild);

            try {
                const response = await fetch(`/api/messages?room_id=${roomId}&page=${currentPage}&limit=20`);
                const messages = await response.json();

                if (messages.length < 20) {
                    hasMore = false;
                }

                // Store the current scroll height
                const scrollHeight = messagesDiv.scrollHeight;

                messages.forEach(msg => {
                    displayMessage(msg, true);
                });

                // Adjust scroll position to maintain relative position
                messagesDiv.scrollTop = messagesDiv.scrollHeight - scrollHeight;

                currentPage++;
            } catch (error) {
                console.error('Error loading messages:', error);
            } finally {
                loadingDiv.remove();
                isLoading = false;
            }
        }

        function displayMessage(msg, isPast = false) {
            const msgElm = document.createElement('div');
            msgElm.className = 'message';
            const time = new Date(msg.timestamp).toLocaleTimeString();
            
            if (msg.type === "system") {
                msgElm.innerHTML = `<i>${msg.content}</i>`;
            } else {
                msgElm.innerHTML = `<b>${msg.nickname || msg.sender_id}</b> (${time}): ${msg.content}`;
            }
            
            if (isPast) {
                messagesDiv.insertBefore(msgElm, messagesDiv.firstChild);
            } else {
                messagesDiv.appendChild(msgElm);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }

        async function registerUser() {
            try {
                const response = await fetch('/api/register-user', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        room_id: roomId,
                        nickname: nickname
                    })
                });

                const data = await response.json();

                // If user is already registered, that's fine - proceed to connect
                if (response.status === 400 && data.error && data.error.includes("already registered")) {
                    connectWebSocket();
                    return;
                }

                // For other errors, throw them
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to register user');
                }

                // If registration was successful, connect to WebSocket
                connectWebSocket();
            } catch (error) {
                console.error('Error registering user:', error);
                // Don't try to connect if registration failed (except for "already registered" case)
                return;
            }
        }

        // Initialize connection
        registerUser();

        // WebSocket connection
        let ws;

        function connectWebSocket() {
            if (ws) {
                // Close existing connection before creating a new one
                ws.close();
            }

            ws = new WebSocket(`ws://${window.location.host}/api/ws?room_id=${roomId}&user_id=${userId}&nickname=${nickname}`);
            
            ws.onmessage = function(e) {
                const msg = JSON.parse(e.data);
                displayMessage(msg);
            };

            ws.onerror = function(e) {
                console.error('WebSocket error:', e);
            };

            ws.onopen = function() {
                console.log('WebSocket connected');
                loadMessages(); // Load messages after connection is established
            };

            ws.onclose = function(e) {
                console.log('WebSocket closed:', e.code, e.reason);
                // Attempt to reconnect after a delay
                setTimeout(connectWebSocket, 3000);
            };
        }

        function sendMessage() {
            if (!messageInput.value.trim() || !ws) return;
            
            try {
                const message = {
                    type: "text",
                    content: messageInput.value,
                    room_id: roomId,
                    nickname: nickname,
                    timestamp: new Date()
                };
                
                ws.send(JSON.stringify(message));
                messageInput.value = '';
            } catch (error) {
                console.error('Error sending message:', error);
                // Attempt to reconnect if connection is lost
                connectWebSocket();
            }
        }

        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        async function lockRoom() {
            try {
                const response = await fetch(`/api/rooms/${roomId}/lock`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        room_id: roomId
                    })
                });
                
                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.error || 'Failed to lock room');
                }
                
                const result = await response.json();
                console.log('Room locked:', result);
            } catch (error) {
                console.error('Error locking room:', error);
            }
        }
    </script>
</body>
</html> 